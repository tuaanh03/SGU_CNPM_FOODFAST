import { Kafka, Partitioners } from "kafkajs";
import { processPayment } from "./vnpay";
import prisma from "../lib/prisma";

const kafka = new Kafka({
  clientId: "payment-service",
  brokers: ["kafka:9092"],
  retry: {
    initialRetryTime: 100,
    maxRetryTime: 30000,
    retries: 10,
    factor: 0.2,
  },
});

const producer = kafka.producer({
  createPartitioner: Partitioners.DefaultPartitioner,
});
let isProducerConnected = false;

/**
 * Logic c·ªßa Payment Service:
 * 1. T·∫°o PaymentIntent v·ªõi tr·∫°ng th√°i REQUIRES_PAYMENT
 * 2. T·∫°o PaymentAttempt ƒë·∫ßu ti√™n v·ªõi tr·∫°ng th√°i CREATED
 * 3. G·ªçi API VNPay ƒë·ªÉ t·∫°o paymentUrl
 * 4. C·∫≠p nh·∫≠t PaymentAttempt v·ªõi paymentUrl
 */
async function createPaymentIntent(
  orderId: string,
  userId: string,
  amount: number,
  description: string
) {
  try {
    // B∆∞·ªõc 1: T·∫°o PaymentIntent
    const paymentIntent = await prisma.paymentIntent.create({
      data: {
        orderId,
        amount,
        currency: "VND",
        status: "REQUIRES_PAYMENT",
        metadata: {
          userId,
          description,
          createdAt: new Date().toISOString()
        }
      }
    });

    console.log(`PaymentIntent created: ${paymentIntent.id} for order ${orderId}`);

    // B∆∞·ªõc 2: T·∫°o PaymentAttempt ƒë·∫ßu ti√™n
    const vnpTxnRef = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    const paymentAttempt = await prisma.paymentAttempt.create({
      data: {
        paymentIntentId: paymentIntent.id,
        amount,
        currency: "VND",
        status: "CREATED",
        pspProvider: "VNPAY",
        vnpTxnRef,
        metadata: {
          userId,
          description,
          orderId
        }
      }
    });

    console.log(`PaymentAttempt created: ${paymentAttempt.id} for PaymentIntent ${paymentIntent.id}`);

    // B∆∞·ªõc 3: G·ªçi API VNPay ƒë·ªÉ t·∫°o paymentUrl
    const vnpayResult = await processPayment(
      orderId,
      userId,
      amount,
      description
    );

    if (vnpayResult.success && vnpayResult.paymentUrl) {
      // C·∫≠p nh·∫≠t PaymentAttempt v·ªõi status PROCESSING
      await prisma.paymentAttempt.update({
        where: { id: paymentAttempt.id },
        data: {
          status: "PROCESSING",
          vnpRawRequestPayload: {
            paymentUrl: vnpayResult.paymentUrl,
            timestamp: new Date().toISOString()
          }
        }
      });

      // C·∫≠p nh·∫≠t PaymentIntent status
      await prisma.paymentIntent.update({
        where: { id: paymentIntent.id },
        data: {
          status: "PROCESSING"
        }
      });

      console.log(`VNPay payment URL created for order ${orderId}`);

      return {
        success: true,
        paymentIntentId: paymentIntent.id,
        paymentAttemptId: paymentAttempt.id,
        paymentUrl: vnpayResult.paymentUrl
      };
    } else {
      // C·∫≠p nh·∫≠t PaymentAttempt v√† PaymentIntent th√†nh FAILED
      await prisma.paymentAttempt.update({
        where: { id: paymentAttempt.id },
        data: {
          status: "FAILED"
        }
      });

      await prisma.paymentIntent.update({
        where: { id: paymentIntent.id },
        data: {
          status: "FAILED"
        }
      });

      return {
        success: false,
        paymentIntentId: paymentIntent.id,
        error: vnpayResult.error || "Failed to create payment URL"
      };
    }
  } catch (error: any) {
    console.error("Error creating PaymentIntent:", error);
    return {
      success: false,
      error: error.message || "Error creating payment intent"
    };
  }
}

export async function publishEvent(
  orderId: string,
  userId: string,
  email: string,
  amount: number,
  item: string,
  paymentStatus: string,
  paymentIntentId: string,
  paymentUrl?: string
) {
  if (!isProducerConnected) {
    await producer.connect();
    isProducerConnected = true;
  }

  const messageData = {
    orderId,
    userId,
    email,
    amount,
    item,
    paymentStatus,
    paymentIntentId,
    paymentUrl,
  };

  await producer.send({
    topic: "payment.event",
    messages: [
      { key: `message-${Date.now()}`, value: JSON.stringify(messageData) },
    ],
  });
}

const consumer = kafka.consumer({
  groupId: "payment-service-group",
});

/**
 * X·ª≠ l√Ω khi order h·∫øt h·∫°n
 * C·∫≠p nh·∫≠t PaymentIntent th√†nh FAILED v√† PaymentAttempt th√†nh CANCELED
 */
async function handleOrderExpired(data: any) {
  const { orderId, reason, timestamp } = data;

  try {
    console.log(`‚è∞ Handling expired order: ${orderId}, reason: ${reason}`);

    // T√¨m PaymentIntent c·ªßa order
    const paymentIntent = await prisma.paymentIntent.findUnique({
      where: { orderId },
      include: {
        attempts: {
          where: {
            status: {
              in: ["CREATED", "PROCESSING"]
            }
          }
        }
      }
    });

    if (!paymentIntent) {
      console.log(`No PaymentIntent found for order ${orderId}`);
      return;
    }

    // C·∫≠p nh·∫≠t PaymentIntent th√†nh FAILED
    await prisma.paymentIntent.update({
      where: { id: paymentIntent.id },
      data: {
        status: "FAILED",
        metadata: {
          ...(typeof paymentIntent.metadata === 'object' ? paymentIntent.metadata : {}),
          expiredAt: timestamp,
          expiredReason: reason
        }
      }
    });

    console.log(`‚úÖ Updated PaymentIntent ${paymentIntent.id} to FAILED`);

    // C·∫≠p nh·∫≠t t·∫•t c·∫£ PaymentAttempt ƒëang CREATED ho·∫∑c PROCESSING th√†nh CANCELED
    if (paymentIntent.attempts.length > 0) {
      const attemptIds = paymentIntent.attempts.map((a: any) => a.id);

      await prisma.paymentAttempt.updateMany({
        where: {
          id: { in: attemptIds }
        },
        data: {
          status: "CANCELED"
        }
      });

      console.log(`‚úÖ Canceled ${paymentIntent.attempts.length} PaymentAttempt(s) for order ${orderId}`);
    }

  } catch (error) {
    console.error(`Error handling expired order ${orderId}:`, error);
  }
}

/**
 * X·ª≠ l√Ω retry payment - t·∫°o PaymentAttempt m·ªõi cho PaymentIntent c≈©
 */
async function retryPaymentIntent(
  orderId: string,
  userId: string,
  amount: number,
  description: string
) {
  try {
    console.log(`üîÑ Retrying payment for order ${orderId}`);

    // T√¨m PaymentIntent c≈©
    const existingPaymentIntent = await prisma.paymentIntent.findUnique({
      where: { orderId }
    });

    if (!existingPaymentIntent) {
      console.error(`PaymentIntent not found for order ${orderId}. Creating new one...`);
      // N·∫øu kh√¥ng t√¨m th·∫•y PaymentIntent c≈©, t·∫°o m·ªõi
      return await createPaymentIntent(orderId, userId, amount, description);
    }

    console.log(`Found existing PaymentIntent: ${existingPaymentIntent.id}`);

    // C·∫≠p nh·∫≠t PaymentIntent status v·ªÅ REQUIRES_PAYMENT n·∫øu ƒëang FAILED
    if (existingPaymentIntent.status === "FAILED") {
      await prisma.paymentIntent.update({
        where: { id: existingPaymentIntent.id },
        data: { status: "REQUIRES_PAYMENT" }
      });
      console.log(`Updated PaymentIntent ${existingPaymentIntent.id} status to REQUIRES_PAYMENT`);
    }

    // T·∫°o PaymentAttempt m·ªõi
    const vnpTxnRef = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    const paymentAttempt = await prisma.paymentAttempt.create({
      data: {
        paymentIntentId: existingPaymentIntent.id,
        amount,
        currency: "VND",
        status: "CREATED",
        pspProvider: "VNPAY",
        vnpTxnRef,
        metadata: {
          userId,
          description,
          orderId,
          isRetry: true,
          retryAt: new Date().toISOString()
        }
      }
    });

    console.log(`‚úÖ Created new PaymentAttempt: ${paymentAttempt.id} (retry) for PaymentIntent ${existingPaymentIntent.id}`);

    // T·∫°o URL thanh to√°n VNPay m·ªõi
    const vnpayResult = await processPayment(
      orderId,
      userId,
      amount,
      description
    );

    if (vnpayResult.success && vnpayResult.paymentUrl) {
      // C·∫≠p nh·∫≠t PaymentAttempt v·ªõi status PROCESSING
      await prisma.paymentAttempt.update({
        where: { id: paymentAttempt.id },
        data: {
          status: "PROCESSING",
          vnpRawRequestPayload: {
            paymentUrl: vnpayResult.paymentUrl,
            timestamp: new Date().toISOString()
          }
        }
      });

      // C·∫≠p nh·∫≠t PaymentIntent status
      await prisma.paymentIntent.update({
        where: { id: existingPaymentIntent.id },
        data: {
          status: "PROCESSING"
        }
      });

      console.log(`‚úÖ VNPay payment URL created for retry order ${orderId}`);

      return {
        success: true,
        paymentIntentId: existingPaymentIntent.id,
        paymentAttemptId: paymentAttempt.id,
        paymentUrl: vnpayResult.paymentUrl,
        isRetry: true
      };
    } else {
      // C·∫≠p nh·∫≠t PaymentAttempt th√†nh FAILED
      await prisma.paymentAttempt.update({
        where: { id: paymentAttempt.id },
        data: {
          status: "FAILED"
        }
      });

      return {
        success: false,
        paymentIntentId: existingPaymentIntent.id,
        error: vnpayResult.error || "Failed to create payment URL for retry"
      };
    }
  } catch (error: any) {
    console.error("Error retrying PaymentIntent:", error);
    return {
      success: false,
      error: error.message || "Error retrying payment intent"
    };
  }
}

export async function runConsumer() {
  try {
    await consumer.connect();
    await consumer.subscribe({ topic: "order.create", fromBeginning: true });
    await consumer.subscribe({ topic: "order.retry.payment", fromBeginning: true });
    await consumer.subscribe({ topic: "order.expired", fromBeginning: true });
    console.log("Consumer is listening to order.create, order.retry.payment, and order.expired");

    // Process messages
    await consumer.run({
      eachMessage: async ({ topic, message }) => {
        const orderData = JSON.parse(message.value?.toString() || "{}");

        // X·ª≠ l√Ω order.expired event
        if (topic === "order.expired") {
          await handleOrderExpired(orderData);
          return;
        }

        // X·ª≠ l√Ω order.create event v√† order.retry.payment event
        const { orderId, userId, totalPrice, items, isRetry } = orderData;
        const isRetryPayment = topic === "order.retry.payment" || isRetry === true;

        if (!orderId || !userId || !totalPrice) {
          console.error("Invalid order data:", orderData);
          return;
        }

        console.log(`Processing payment for order ${orderId}${isRetryPayment ? ' (RETRY)' : ''}`);

        // T·∫°o m√¥ t·∫£ ƒë∆°n h√†ng t·ª´ items
        const orderDescription =
          items && items.length > 0
            ? `Order ${orderId} - ${items.length} items`
            : `Order ${orderId}`;

        // Ki·ªÉm tra n·∫øu l√† retry payment
        let result;
        if (isRetryPayment) {
          // G·ªçi retryPaymentIntent ƒë·ªÉ t√¨m PaymentIntent c≈© v√† t·∫°o PaymentAttempt m·ªõi
          result = await retryPaymentIntent(
            orderId,
            userId,
            totalPrice,
            orderDescription
          );
        } else {
          // G·ªçi createPaymentIntent ƒë·ªÉ t·∫°o PaymentIntent v√† PaymentAttempt m·ªõi
          result = await createPaymentIntent(
            orderId,
            userId,
            totalPrice,
            orderDescription
          );
        }

        console.log(`Payment processing result for order ${orderId}:`, result);

        if (result.success && result.paymentUrl) {
          const paymentIntentId = result.paymentIntentId!;

          // Publish event v·ªõi payment URL ƒë·ªÉ frontend c√≥ th·ªÉ redirect
          await publishEvent(
            orderId,
            userId,
            "system@vnpay.com",
            totalPrice,
            orderDescription,
            "pending",
            paymentIntentId,
            result.paymentUrl
          );

          console.log(`Payment URL sent for order ${orderId}: ${result.paymentUrl}`);
        } else {
          // N·∫øu l√† retry v√† failed, kh√¥ng publish event "failed"
          // V√¨ PaymentIntent v·∫´n REQUIRES_PAYMENT, user c√≥ th·ªÉ retry l·∫°i
          if (isRetryPayment) {
            console.error(`‚ùå Retry payment failed for order ${orderId}: ${'error' in result ? result.error : 'Unknown error'}`);
            console.log(`User can retry again. PaymentIntent still active.`);
            // Kh√¥ng publish event ƒë·ªÉ tr√°nh Order Service x√≥a session
          } else {
            // N·∫øu l√† l·∫ßn t·∫°o ƒë·∫ßu ti√™n v√† failed, publish event "failed"
            const paymentIntentId = result.paymentIntentId || "N/A";
            await publishEvent(
              orderId,
              userId,
              "system@vnpay.com",
              totalPrice,
              orderDescription,
              "failed",
              paymentIntentId,
              ""
            );
          }
        }
      },
    });
  } catch (error) {
    console.error("Error in Kafka consumer:", error);
  }
}

// Graceful shutdown
process.on("SIGINT", async () => {
  await producer.disconnect();
  await consumer.disconnect();
  console.log("Kafka producer and consumer disconnected");
  process.exit();
});

