# üîÑ RETRY PAYMENT WORKFLOW - CHI TI·∫æT QUY TR√åNH

## üìã M·ª§C L·ª§C

1. [T·ªïng Quan Retry Payment](#t·ªïng-quan-retry-payment)
2. [Workflow Chi Ti·∫øt - Step by Step](#workflow-chi-ti·∫øt---step-by-step)
3. [Communication Flow](#communication-flow)
4. [Database State Changes](#database-state-changes)
5. [Redis Session Management](#redis-session-management)
6. [Test Coverage Analysis](#test-coverage-analysis)
7. [C√°c Tr∆∞·ªùng H·ª£p Ch∆∞a Test](#c√°c-tr∆∞·ªùng-h·ª£p-ch∆∞a-test)

---

## üéØ T·ªîNG QUAN RETRY PAYMENT

### Khi N√†o User Retry Payment?

```
Scenario 1: User ƒë√≥ng tab khi ƒëang ·ªü VNPay
  ‚Üí Quay l·∫°i trang order status
  ‚Üí Click "Thanh to√°n l·∫°i"

Scenario 2: User b·∫•m Back button t·ª´ VNPay
  ‚Üí V·ªÅ trang merchant
  ‚Üí Click "Ti·∫øp t·ª•c thanh to√°n"

Scenario 3: User b·∫•m "H·ªßy giao d·ªãch" tr√™n VNPay
  ‚Üí VNPay redirect v·ªÅ merchant v·ªõi response code 24
  ‚Üí Session v·∫´n c√≤n ‚Üí Click "Th·ª≠ l·∫°i"

Scenario 4: Payment timeout tr√™n VNPay
  ‚Üí User quay l·∫°i
  ‚Üí Session c√≤n h·∫°n ‚Üí Retry
```

### Key Principles

‚úÖ **PaymentIntent ƒë∆∞·ª£c t√°i s·ª≠ d·ª•ng** (1 Order = 1 PaymentIntent)  
‚úÖ **PaymentAttempt m·ªõi ƒë∆∞·ª£c t·∫°o** (m·ªói l·∫ßn retry = 1 attempt m·ªõi)  
‚úÖ **Redis session KH√îNG b·ªã x√≥a** khi retry  
‚úÖ **Inventory KH√îNG ƒë∆∞·ª£c check l·∫°i** (ƒë√£ reserve t·ª´ l·∫ßn ƒë·∫ßu)  
‚úÖ **VNPay URL m·ªõi ƒë∆∞·ª£c generate** (vnp_TxnRef kh√°c nhau)

---

## üîÑ WORKFLOW CHI TI·∫æT - STEP BY STEP

### STEP 1: User Initiates Retry

**Action:** User clicks "Thanh to√°n l·∫°i" button

**Frontend:**
```typescript
POST /order/retry-payment/:orderId
Headers: {
  Authorization: "Bearer <JWT_TOKEN>"
}
```

**Request:**
```json
{
  "orderId": "order-123-abc"
}
```

---

### STEP 2: Order Service Validates Request

**Controller:** `retryPayment()` in `order-service/src/controllers/order.ts`

#### Validation Checks:

```typescript
// ‚úÖ Check 1: User authenticated
if (!userId) {
  return 401: "Unauthorized"
}

// ‚úÖ Check 2: Order exists and belongs to user
const order = await prisma.order.findUnique({
  where: { id: orderId, userId }
});

if (!order) {
  return 404: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng"
}

// ‚úÖ Check 3: Order status = pending
if (order.status === "success") {
  return 400: "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c thanh to√°n th√†nh c√¥ng"
}

if (order.status !== "pending") {
  return 400: "ƒê∆°n h√†ng kh√¥ng ·ªü tr·∫°ng th√°i ch·ªù thanh to√°n"
}

// ‚úÖ Check 4: Redis session exists
const sessionExists = await checkOrderSession(orderId);

if (!sessionExists) {
  // Session h·∫øt h·∫°n ‚Üí C·∫≠p nh·∫≠t order = cancelled
  await prisma.order.update({
    where: { id: orderId },
    data: { status: 'cancelled' }
  });
  
  return 400: "Phi√™n thanh to√°n ƒë√£ h·∫øt h·∫°n"
}

// ‚úÖ Check 5: Session TTL > 0
const ttlSeconds = await getSessionTTL(orderId);

if (ttlSeconds <= 0) {
  return 400: "Phi√™n thanh to√°n ƒë√£ h·∫øt h·∫°n"
}
```

**üîç ƒêi·ªÉm Quan Tr·ªçng:**
- ‚úÖ **TTL KH√îNG b·ªã reset** khi retry
- ‚úÖ **Session countdown ti·∫øp t·ª•c** t·ª´ th·ªùi ƒëi·ªÉm ban ƒë·∫ßu
- ‚úÖ **Order status v·∫´n = pending**

---

### STEP 3: Publish Kafka Event - order.retry.payment

**Order Service publishes:**

```typescript
// utils/kafka.ts - publishRetryPaymentEvent()

Topic: "order.retry.payment"

Payload: {
  orderId: "order-123-abc",
  userId: "user-456-def",
  totalPrice: 100000,
  items: [
    {
      productId: "prod-001",
      productName: "Burger King",
      productPrice: 50000,
      quantity: 2
    }
  ],
  isRetry: true,  // ‚≠ê FLAG ƒê·∫∂C BI·ªÜT
  expiresAt: "2025-10-30T15:00:00Z",
  timestamp: "2025-10-30T14:50:00Z"
}
```

**üéØ Consumers c·ªßa topic n√†y:**
- ‚úÖ **Payment Service** - X·ª≠ l√Ω retry
- ‚ùå **Inventory Service** - KH√îNG l·∫Øng nghe (tr√°nh check l·∫°i)
- ‚ùå **Notification Service** - KH√îNG l·∫Øng nghe

---

### STEP 4: Payment Service Consumes Event

**Consumer:** `payment-service/src/utils/kafka.ts`

```typescript
await consumer.subscribe({ topic: "order.retry.payment" });

await consumer.run({
  eachMessage: async ({ topic, message }) => {
    const { orderId, userId, totalPrice, items, isRetry } = JSON.parse(message.value);
    
    const isRetryPayment = topic === "order.retry.payment" || isRetry === true;
    
    if (isRetryPayment) {
      // ‚≠ê G·ªçi retryPaymentIntent (KH√îNG ph·∫£i createPaymentIntent)
      result = await retryPaymentIntent(
        orderId,
        userId,
        totalPrice,
        orderDescription
      );
    } else {
      result = await createPaymentIntent(...);
    }
  }
});
```

---

### STEP 5: Find Existing PaymentIntent

**Function:** `retryPaymentIntent()` in `payment-service/src/utils/kafka.ts`

```typescript
async function retryPaymentIntent(orderId, userId, amount, description) {
  console.log(`üîÑ Retrying payment for order ${orderId}`);
  
  // ‚≠ê T√¨m PaymentIntent c≈©
  const existingPaymentIntent = await prisma.paymentIntent.findUnique({
    where: { orderId }
  });
  
  if (!existingPaymentIntent) {
    console.error(`PaymentIntent not found. Creating new one...`);
    return await createPaymentIntent(...);  // Fallback
  }
  
  console.log(`‚úÖ Found existing PaymentIntent: ${existingPaymentIntent.id}`);
  
  // Ti·∫øp t·ª•c...
}
```

**Database Query:**
```sql
SELECT * FROM PaymentIntent WHERE orderId = 'order-123-abc';

-- Result:
{
  id: 'pi-001',
  orderId: 'order-123-abc',
  userId: 'user-456-def',
  amount: 100000,
  currency: 'VND',
  status: 'PROCESSING',  -- C√≥ th·ªÉ l√† REQUIRES_PAYMENT ho·∫∑c FAILED
  createdAt: '2025-10-30T14:30:00Z',
  updatedAt: '2025-10-30T14:30:00Z'
}
```

---

### STEP 6: Update PaymentIntent Status (if needed)

```typescript
// N·∫øu PaymentIntent ƒëang FAILED ‚Üí Chuy·ªÉn v·ªÅ REQUIRES_PAYMENT
if (existingPaymentIntent.status === "FAILED") {
  await prisma.paymentIntent.update({
    where: { id: existingPaymentIntent.id },
    data: { status: "REQUIRES_PAYMENT" }
  });
  
  console.log(`‚úÖ Updated PaymentIntent to REQUIRES_PAYMENT`);
}
```

**Database Update:**
```sql
UPDATE PaymentIntent
SET status = 'REQUIRES_PAYMENT', updatedAt = NOW()
WHERE id = 'pi-001' AND status = 'FAILED';
```

---

### STEP 7: Create New PaymentAttempt

```typescript
// ‚≠ê T·∫°o PaymentAttempt M·ªöI (kh√¥ng reuse attempt c≈©)
const vnpTxnRef = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

const paymentAttempt = await prisma.paymentAttempt.create({
  data: {
    paymentIntentId: existingPaymentIntent.id,  // Link to existing PI
    amount: amount,
    currency: "VND",
    status: "CREATED",
    pspProvider: "VNPAY",
    vnpTxnRef: vnpTxnRef,  // ‚≠ê M·ªöI - kh√°c v·ªõi attempt c≈©
    metadata: {
      userId: userId,
      description: description,
      orderId: orderId,
      isRetry: true,  // ‚≠ê Flag ƒë√°nh d·∫•u retry
      retryAt: new Date().toISOString()
    }
  }
});

console.log(`‚úÖ Created PaymentAttempt: ${paymentAttempt.id} (retry)`);
```

**Database Insert:**
```sql
INSERT INTO PaymentAttempt (
  id, paymentIntentId, vnpTxnRef, status, amount, currency, 
  pspProvider, metadata, createdAt, updatedAt
)
VALUES (
  'pa-002',
  'pi-001',  -- ‚≠ê Same PaymentIntent
  '1730304600000-xyz789',  -- ‚≠ê NEW vnpTxnRef
  'CREATED',
  100000,
  'VND',
  'VNPAY',
  '{"isRetry": true, "retryAt": "2025-10-30T14:50:00Z"}',
  NOW(),
  NOW()
);
```

**‚≠ê K·∫øt qu·∫£:** B√¢y gi·ªù c√≥ 2 PaymentAttempt cho c√πng 1 PaymentIntent:

```sql
SELECT * FROM PaymentAttempt WHERE paymentIntentId = 'pi-001';

-- Results:
[
  {
    id: 'pa-001',
    paymentIntentId: 'pi-001',
    vnpTxnRef: '1730301000000-abc123',  -- Attempt 1
    status: 'PROCESSING',
    createdAt: '2025-10-30T14:30:00Z'
  },
  {
    id: 'pa-002',
    paymentIntentId: 'pi-001',
    vnpTxnRef: '1730304600000-xyz789',  -- Attempt 2 (RETRY)
    status: 'CREATED',
    createdAt: '2025-10-30T14:50:00Z',
    metadata: { isRetry: true }
  }
]
```

---

### STEP 8: Generate New VNPay Payment URL

```typescript
// T·∫°o URL VNPay m·ªõi
const vnpayResult = await processPayment(
  orderId,
  userId,
  amount,
  description
);

if (vnpayResult.success && vnpayResult.paymentUrl) {
  // ‚úÖ C·∫≠p nh·∫≠t PaymentAttempt ‚Üí PROCESSING
  await prisma.paymentAttempt.update({
    where: { id: paymentAttempt.id },
    data: {
      status: "PROCESSING",
      vnpRawRequestPayload: {
        paymentUrl: vnpayResult.paymentUrl,
        timestamp: new Date().toISOString()
      }
    }
  });
  
  // ‚úÖ C·∫≠p nh·∫≠t PaymentIntent ‚Üí PROCESSING
  await prisma.paymentIntent.update({
    where: { id: existingPaymentIntent.id },
    data: { status: "PROCESSING" }
  });
  
  console.log(`‚úÖ New VNPay URL: ${vnpayResult.paymentUrl}`);
}
```

**VNPay URL Format:**
```
https://sandbox.vnpayment.vn/paymentv2/vpcpay.html?
  vnp_TxnRef=1730304600000-xyz789  ‚Üê ‚≠ê M·ªöI
  &vnp_Amount=10000000
  &vnp_OrderInfo=Order+order-123-abc
  &vnp_ReturnUrl=http://localhost:3000/payment/vnpay/return
  &...
```

**Database Updates:**
```sql
-- Update PaymentAttempt
UPDATE PaymentAttempt
SET status = 'PROCESSING',
    vnpRawRequestPayload = '{"paymentUrl": "https://...", "timestamp": "..."}',
    updatedAt = NOW()
WHERE id = 'pa-002';

-- Update PaymentIntent
UPDATE PaymentIntent
SET status = 'PROCESSING', updatedAt = NOW()
WHERE id = 'pi-001';
```

---

### STEP 9: Publish payment.event with New URL

**Payment Service publishes:**

```typescript
await publishEvent(
  orderId,
  userId,
  "system@vnpay.com",
  totalPrice,
  orderDescription,
  "pending",  // ‚≠ê Status = pending
  paymentIntentId,
  vnpayResult.paymentUrl  // ‚≠ê NEW payment URL
);
```

**Kafka Message:**
```json
Topic: "payment.event"

Payload: {
  orderId: "order-123-abc",
  userId: "user-456-def",
  paymentStatus: "pending",  // ‚≠ê NOT "failed"
  paymentIntentId: "pi-001",
  paymentUrl: "https://sandbox.vnpayment.vn/...",  // ‚≠ê NEW URL
  timestamp: "2025-10-30T14:50:05Z"
}
```

---

### STEP 10: Order Service Receives payment.event

**Consumer:** `order-service/src/utils/kafka.ts`

```typescript
await consumer.subscribe({ topic: "payment.event" });

await consumer.run({
  eachMessage: async ({ topic, message }) => {
    const { orderId, paymentStatus, paymentUrl } = JSON.parse(message.value);
    
    if (paymentStatus === "pending" && paymentUrl) {
      // ‚úÖ Order status v·∫´n = pending
      // ‚úÖ Redis session KH√îNG b·ªã x√≥a
      // ‚úÖ User nh·∫≠n ƒë∆∞·ª£c payment URL m·ªõi
      
      console.log(`‚úÖ Retry payment URL ready: ${paymentUrl}`);
      
      // C√≥ th·ªÉ publish order.payment.url.ready ƒë·ªÉ notify frontend
    }
  }
});
```

---

### STEP 11: Frontend Receives New Payment URL

**Response to Client:**
```json
{
  "success": true,
  "message": "ƒê√£ t·∫°o URL thanh to√°n m·ªõi",
  "data": {
    "orderId": "order-123-abc",
    "paymentUrl": "https://sandbox.vnpayment.vn/...",
    "expiresAt": "2025-10-30T15:00:00Z",
    "sessionRemainingMinutes": 10,  // ‚≠ê TTL c√≤n l·∫°i
    "isRetry": true
  }
}
```

**Frontend Action:**
```typescript
// Auto-redirect to VNPay
window.location.href = response.data.paymentUrl;

// Or show button
<button onClick={() => window.location.href = paymentUrl}>
  Thanh to√°n ngay
</button>
```

---

## üîó COMMUNICATION FLOW

### C√°ch PaymentAttempt Th√¥ng B√°o Cho PaymentIntent

**‚ùå KH√îNG c√≥ communication tr·ª±c ti·∫øp**

PaymentAttempt v√† PaymentIntent l√† **database entities**, kh√¥ng "th√¥ng b√°o" cho nhau. Thay v√†o ƒë√≥:

```
PaymentAttempt (pa-002) ƒë∆∞·ª£c t·∫°o
    ‚Üì
Linked to PaymentIntent (pi-001) via paymentIntentId
    ‚Üì
Payment Service c·∫≠p nh·∫≠t c·∫£ 2:
    ‚îú‚îÄ UPDATE PaymentAttempt SET status = 'PROCESSING'
    ‚îî‚îÄ UPDATE PaymentIntent SET status = 'PROCESSING'
```

**Code Flow:**
```typescript
// STEP 1: Create PaymentAttempt
const paymentAttempt = await prisma.paymentAttempt.create({
  data: {
    paymentIntentId: existingPaymentIntent.id,  // ‚≠ê Link
    status: "CREATED",
    // ...
  }
});

// STEP 2: Update PaymentAttempt
await prisma.paymentAttempt.update({
  where: { id: paymentAttempt.id },
  data: { status: "PROCESSING" }
});

// STEP 3: Update PaymentIntent
await prisma.paymentIntent.update({
  where: { id: existingPaymentIntent.id },
  data: { status: "PROCESSING" }
});
```

**Database Relationship:**
```prisma
model PaymentIntent {
  id        String   @id
  orderId   String   @unique
  status    String
  attempts  PaymentAttempt[]  // ‚≠ê One-to-Many
}

model PaymentAttempt {
  id               String   @id
  paymentIntentId  String
  paymentIntent    PaymentIntent @relation(fields: [paymentIntentId], references: [id])
  status           String
}
```

---

### C√°ch PaymentIntent Th√¥ng B√°o Cho Order

**‚úÖ Qua Kafka Event: payment.event**

```
Payment Service (PaymentIntent updated)
    ‚Üì
Publish Kafka: payment.event
    ‚Üì
Order Service consumes
    ‚Üì
Update Order status
```

**Chi Ti·∫øt:**

```typescript
// Payment Service
async function updatePaymentStatus(paymentIntentId, status) {
  // Update PaymentIntent
  const paymentIntent = await prisma.paymentIntent.update({
    where: { id: paymentIntentId },
    data: { status: status }
  });
  
  // ‚≠ê Publish Kafka event
  await kafka.publishEvent(
    paymentIntent.orderId,
    paymentIntent.userId,
    ...,
    status,  // "pending", "success", "failed"
    paymentIntentId,
    paymentUrl
  );
}
```

**Kafka Message:**
```json
Topic: "payment.event"

Payload: {
  orderId: "order-123-abc",
  paymentStatus: "pending" | "success" | "failed",
  paymentIntentId: "pi-001",
  // ... other data
}
```

**Order Service Consumes:**
```typescript
// Order Service - Kafka Consumer
await consumer.subscribe({ topic: "payment.event" });

await consumer.run({
  eachMessage: async ({ message }) => {
    const { orderId, paymentStatus } = JSON.parse(message.value);
    
    // Map payment status ‚Üí order status
    let orderStatus;
    if (paymentStatus === "success") {
      orderStatus = "success";
      await deleteOrderSession(orderId);  // ‚≠ê X√≥a session
    } else if (paymentStatus === "failed") {
      orderStatus = "cancelled";
      await deleteOrderSession(orderId);  // ‚≠ê X√≥a session
    } else {
      orderStatus = "pending";
      // ‚≠ê KH√îNG x√≥a session (user c√≥ th·ªÉ retry)
    }
    
    // Update Order
    await prisma.order.update({
      where: { id: orderId },
      data: { status: orderStatus }
    });
  }
});
```

---

## üìä DATABASE STATE CHANGES

### Before Retry

```sql
-- Order
SELECT * FROM Order WHERE id = 'order-123-abc';
{
  id: 'order-123-abc',
  userId: 'user-456-def',
  status: 'pending',  ‚Üê ‚≠ê
  totalPrice: 100000,
  createdAt: '2025-10-30T14:30:00Z'
}

-- PaymentIntent
SELECT * FROM PaymentIntent WHERE orderId = 'order-123-abc';
{
  id: 'pi-001',
  orderId: 'order-123-abc',
  status: 'PROCESSING',  ‚Üê ‚≠ê
  amount: 100000
}

-- PaymentAttempt
SELECT * FROM PaymentAttempt WHERE paymentIntentId = 'pi-001';
[
  {
    id: 'pa-001',
    paymentIntentId: 'pi-001',
    status: 'PROCESSING',  ‚Üê ‚≠ê
    vnpTxnRef: '1730301000000-abc123',
    createdAt: '2025-10-30T14:30:00Z'
  }
]

-- Redis
redis-cli GET order:session:order-123-abc
{
  orderId: 'order-123-abc',
  userId: 'user-456-def',
  status: 'pending',
  expiresAt: '2025-10-30T15:00:00Z',
  createdAt: '2025-10-30T14:30:00Z'
}

redis-cli TTL order:session:order-123-abc
600  ‚Üê ‚≠ê C√≤n 10 ph√∫t (600 gi√¢y)
```

---

### After Retry

```sql
-- Order (KH√îNG THAY ƒê·ªîI)
{
  id: 'order-123-abc',
  status: 'pending',  ‚Üê ‚≠ê SAME
  totalPrice: 100000
}

-- PaymentIntent (status c√≥ th·ªÉ thay ƒë·ªïi)
{
  id: 'pi-001',
  orderId: 'order-123-abc',
  status: 'PROCESSING',  ‚Üê ‚≠ê C√≥ th·ªÉ t·ª´ FAILED ‚Üí PROCESSING
  amount: 100000,
  updatedAt: '2025-10-30T14:50:00Z'  ‚Üê Updated
}

-- PaymentAttempt (M·ªöI)
[
  {
    id: 'pa-001',
    paymentIntentId: 'pi-001',
    status: 'PROCESSING',  ‚Üê Old attempt (v·∫´n c√≤n)
    vnpTxnRef: '1730301000000-abc123',
    createdAt: '2025-10-30T14:30:00Z'
  },
  {
    id: 'pa-002',  ‚Üê ‚≠ê NEW
    paymentIntentId: 'pi-001',  ‚Üê Same PaymentIntent
    status: 'PROCESSING',
    vnpTxnRef: '1730304600000-xyz789',  ‚Üê ‚≠ê NEW vnpTxnRef
    metadata: { isRetry: true },
    createdAt: '2025-10-30T14:50:00Z'  ‚Üê ‚≠ê NEW timestamp
  }
]

-- Redis (KH√îNG B·ªä X√ìA, TTL GI·∫¢M)
redis-cli GET order:session:order-123-abc
{
  orderId: 'order-123-abc',
  status: 'pending',  ‚Üê ‚≠ê SAME
  expiresAt: '2025-10-30T15:00:00Z'  ‚Üê ‚≠ê SAME
}

redis-cli TTL order:session:order-123-abc
480  ‚Üê ‚≠ê C√≤n 8 ph√∫t (gi·∫£m t·ª´ 10 ph√∫t)
```

**üîç Key Observations:**

1. ‚úÖ **Order status = pending** (kh√¥ng thay ƒë·ªïi)
2. ‚úÖ **PaymentIntent ƒë∆∞·ª£c reuse** (c√πng ID = 'pi-001')
3. ‚úÖ **PaymentAttempt m·ªõi ƒë∆∞·ª£c t·∫°o** (pa-002)
4. ‚úÖ **Old PaymentAttempt v·∫´n t·ªìn t·∫°i** (pa-001 kh√¥ng b·ªã x√≥a)
5. ‚úÖ **Redis session KH√îNG b·ªã x√≥a**
6. ‚úÖ **Redis TTL countdown ti·∫øp t·ª•c** (kh√¥ng reset)

---

## üî¥ REDIS SESSION MANAGEMENT

### Session TTL Behavior During Retry

```
T+0:00  ‚Üí Order created, session created
         SETEX order:session:xxx 900 {...}
         TTL = 900 seconds (15 ph√∫t)

T+5:00  ‚Üí User at VNPay, decides to cancel
         TTL = 600 seconds (10 ph√∫t)
         
T+5:30  ‚Üí User clicks "Retry Payment"
         ‚úÖ Session exists? YES
         ‚úÖ TTL > 0? YES (TTL = 570)
         ‚úÖ Retry ALLOWED
         ‚≠ê TTL KH√îNG RESET (v·∫´n countdown)

T+6:00  ‚Üí New payment URL ready
         TTL = 540 seconds (9 ph√∫t)
         Session: ACTIVE

T+15:00 ‚Üí Session expires (original expiration)
         Redis auto-deletes key
         Order ‚Üí cancelled (if not paid)
```

**üîç Important Points:**

1. ‚úÖ **TTL kh√¥ng reset** khi retry
2. ‚úÖ **Th·ªùi gian h·∫øt h·∫°n gi·ªØ nguy√™n** t·ª´ l√∫c order t·∫°o
3. ‚úÖ **Session countdown li√™n t·ª•c** (kh√¥ng pause)
4. ‚úÖ **User c√≥ th·ªÉ retry nhi·ªÅu l·∫ßn** trong th·ªùi gian TTL > 0

### Redis Commands During Retry

```bash
# Before Retry
redis-cli EXISTS order:session:order-123-abc
1  # Session t·ªìn t·∫°i

redis-cli TTL order:session:order-123-abc
600  # C√≤n 10 ph√∫t

redis-cli GET order:session:order-123-abc
"{\"orderId\":\"order-123-abc\",\"status\":\"pending\",...}"

# After Retry
redis-cli EXISTS order:session:order-123-abc
1  # ‚≠ê V·∫´n t·ªìn t·∫°i (KH√îNG b·ªã x√≥a)

redis-cli TTL order:session:order-123-abc
540  # ‚≠ê Gi·∫£m xu·ªëng c√≤n 9 ph√∫t

redis-cli GET order:session:order-123-abc
"{\"orderId\":\"order-123-abc\",\"status\":\"pending\",...}"
# ‚≠ê Data KH√îNG thay ƒë·ªïi
```

---

## ‚úÖ TEST COVERAGE ANALYSIS

### C√°c Test Cases ƒê√£ C√≥ trong Phase 2

#### 1. ‚úÖ Session TTL Countdown During Retry

**File:** `session-and-retry-logic.test.ts`

```typescript
describe('Test Case 10: Session NOT Deleted on Retry', () => {
  it('should keep Redis session active after retry', () => {
    const sessionTTLBefore = 600;  // Before retry
    const sessionTTLAfter = 600;   // After retry
    
    expect(sessionTTLAfter).toBeGreaterThan(0);
  });
  
  it('should allow multiple retries within session time', () => {
    const retryAttempts = [
      { attemptNumber: 1, sessionTTL: 800 },
      { attemptNumber: 2, sessionTTL: 600 },  // ‚≠ê TTL gi·∫£m d·∫ßn
      { attemptNumber: 3, sessionTTL: 400 },
    ];
    
    retryAttempts.forEach(attempt => {
      expect(attempt.sessionTTL).toBeGreaterThan(0);
    });
  });
});
```

**‚úÖ Status:** ƒê√É TEST (nh∆∞ng gi√° tr·ªã TTL hard-coded, kh√¥ng test th·ª±c t·∫ø)

---

#### 2. ‚úÖ PaymentIntent Status After Retry

**File:** `user-cancels-on-vnpay.test.ts`

```typescript
describe('Test Case 5: PaymentIntent and Attempt Status After Cancel', () => {
  it('should keep PaymentIntent status as PROCESSING after user cancel', () => {
    const paymentIntent = {
      id: 'pi-001',
      status: 'PROCESSING',  // ‚≠ê Kh√¥ng thay ƒë·ªïi khi user cancel
    };
    
    expect(paymentIntent.status).toBe('PROCESSING');
    expect(paymentIntent.status).not.toBe('FAILED');
  });
  
  it('should keep PaymentAttempt status as PROCESSING', () => {
    const paymentAttempt = {
      id: 'pa-001',
      status: 'PROCESSING',  // ‚≠ê V·∫´n PROCESSING
    };
    
    expect(paymentAttempt.status).toBe('PROCESSING');
  });
});
```

**‚úÖ Status:** ƒê√É TEST (mock data, kh√¥ng test database th·ª±c)

---

#### 3. ‚úÖ Retry Flow Timeline

**File:** `session-and-retry-logic.test.ts`

```typescript
describe('Test Case 11: Complete Retry Flow Timeline', () => {
  it('should track complete retry flow', () => {
    const retryTimeline = [
      { step: 1, action: 'Client POST /retry-payment' },
      { step: 2, action: 'Check session active' },
      { step: 5, action: 'Find PaymentIntent' },
      { step: 6, action: 'Create new PaymentAttempt' },
      { step: 7, action: 'Generate VNPay URL' },
      { step: 8, action: 'Publish payment.event' },
    ];
    
    expect(retryTimeline).toHaveLength(9);
  });
});
```

**‚úÖ Status:** ƒê√É TEST (conceptual flow)

---

## ‚ùå C√ÅC TR∆Ø·ªúNG H·ª¢P CH∆ØA TEST

### üî¥ HIGH PRIORITY - C·∫ßn Test Ngay

#### 1. ‚ùå TTL Countdown Th·ª±c T·∫ø Khi Retry

**Thi·∫øu:**
```typescript
it('should verify actual TTL countdown during retry', async () => {
  // Step 1: Create order ‚Üí session TTL = 900s
  const orderId = 'test-order-123';
  await createOrderSession(orderId, 900);
  
  const ttl1 = await redis.ttl(`order:session:${orderId}`);
  expect(ttl1).toBeLessThanOrEqual(900);
  expect(ttl1).toBeGreaterThan(0);
  
  // Step 2: Wait 5 seconds
  await new Promise(resolve => setTimeout(resolve, 5000));
  
  const ttl2 = await redis.ttl(`order:session:${orderId}`);
  expect(ttl2).toBeLessThan(ttl1);  // ‚≠ê TTL ph·∫£i gi·∫£m
  expect(ttl2).toBeGreaterThan(ttl1 - 10);  // Gi·∫£m ~5s
  
  // Step 3: Retry payment
  await POST('/order/retry-payment/' + orderId);
  
  // Step 4: Check TTL after retry
  const ttl3 = await redis.ttl(`order:session:${orderId}`);
  expect(ttl3).toBeLessThan(ttl2);  // ‚≠ê TTL ti·∫øp t·ª•c gi·∫£m
  expect(ttl3).toBeGreaterThan(0);  // ‚≠ê V·∫´n c√≤n h·∫°n
  
  // ‚≠ê TTL KH√îNG reset v·ªÅ 900
  expect(ttl3).not.toBe(900);
});
```

---

#### 2. ‚ùå PaymentIntent Status Transitions Khi Retry

**Thi·∫øu:**
```typescript
describe('PaymentIntent Status Transitions on Retry', () => {
  it('should update PaymentIntent from FAILED to REQUIRES_PAYMENT on retry', async () => {
    // Setup: PaymentIntent with FAILED status
    const paymentIntent = await prisma.paymentIntent.create({
      data: {
        orderId: 'order-123',
        userId: 'user-456',
        status: 'FAILED',
        amount: 100000
      }
    });
    
    expect(paymentIntent.status).toBe('FAILED');
    
    // Retry payment
    await POST('/order/retry-payment/order-123');
    
    // Verify: Status changed to REQUIRES_PAYMENT
    const updated = await prisma.paymentIntent.findUnique({
      where: { id: paymentIntent.id }
    });
    
    expect(updated.status).toBe('REQUIRES_PAYMENT');  // ‚≠ê Changed
  });
  
  it('should keep PaymentIntent status as PROCESSING if already PROCESSING', async () => {
    const paymentIntent = await prisma.paymentIntent.create({
      data: {
        orderId: 'order-456',
        status: 'PROCESSING',
        amount: 100000
      }
    });
    
    await POST('/order/retry-payment/order-456');
    
    const updated = await prisma.paymentIntent.findUnique({
      where: { id: paymentIntent.id }
    });
    
    expect(updated.status).toBe('PROCESSING');  // ‚≠ê Unchanged
  });
});
```

---

#### 3. ‚ùå Multiple PaymentAttempts Cho C√πng PaymentIntent

**Thi·∫øu:**
```typescript
it('should create multiple PaymentAttempts for same PaymentIntent on retry', async () => {
  const orderId = 'order-789';
  
  // Create initial PaymentIntent + PaymentAttempt
  const pi = await createPaymentIntent(orderId, 'user-123', 100000);
  
  const attempts1 = await prisma.paymentAttempt.findMany({
    where: { paymentIntentId: pi.id }
  });
  
  expect(attempts1).toHaveLength(1);
  const firstAttempt = attempts1[0];
  
  // Retry payment
  await POST('/order/retry-payment/' + orderId);
  
  // Wait for Payment Service to process
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Verify: 2 attempts now
  const attempts2 = await prisma.paymentAttempt.findMany({
    where: { paymentIntentId: pi.id }
  });
  
  expect(attempts2).toHaveLength(2);  // ‚≠ê NEW attempt created
  
  // Verify: Different vnpTxnRef
  const secondAttempt = attempts2.find(a => a.id !== firstAttempt.id);
  expect(secondAttempt.vnpTxnRef).not.toBe(firstAttempt.vnpTxnRef);  // ‚≠ê UNIQUE
  
  // Verify: metadata.isRetry = true
  expect(secondAttempt.metadata.isRetry).toBe(true);
});
```

---

#### 4. ‚ùå PaymentAttempt Status Khi Cancelled

**Thi·∫øu:**
```typescript
describe('PaymentAttempt Status When User Cancels on VNPay', () => {
  it('should keep old PaymentAttempt as PROCESSING when user cancels', async () => {
    // User ƒë·∫øn VNPay, b·∫•m cancel (ch∆∞a c√≥ IPN callback)
    const paymentAttempt = await prisma.paymentAttempt.findUnique({
      where: { id: 'pa-001' }
    });
    
    // ‚≠ê Status v·∫´n PROCESSING (ch∆∞a c√≥ response t·ª´ VNPay)
    expect(paymentAttempt.status).toBe('PROCESSING');
    expect(paymentAttempt.status).not.toBe('CANCELED');
  });
  
  it('should update PaymentAttempt to CANCELED when IPN callback received', async () => {
    // Phase 3 scope - VNPay g·ª≠i IPN v·ªõi response code 24
    // Payment Service nh·∫≠n IPN
    await handleVNPayIPN({
      vnp_TxnRef: 'pa-001',
      vnp_ResponseCode: '24',  // User cancelled
    });
    
    const paymentAttempt = await prisma.paymentAttempt.findUnique({
      where: { vnpTxnRef: 'pa-001' }
    });
    
    expect(paymentAttempt.status).toBe('CANCELED');  // ‚≠ê Updated
  });
});
```

---

#### 5. ‚ùå Order Status Kh√¥ng Thay ƒê·ªïi Khi Retry

**Thi·∫øu:**
```typescript
it('should NOT change Order status when retry payment', async () => {
  const orderId = 'order-999';
  
  // Setup: Order with status = pending
  const order = await prisma.order.create({
    data: {
      id: orderId,
      userId: 'user-123',
      status: 'pending',
      totalPrice: 100000
    }
  });
  
  expect(order.status).toBe('pending');
  
  // Retry payment
  await POST('/order/retry-payment/' + orderId);
  
  // Verify: Order status still pending
  const orderAfter = await prisma.order.findUnique({
    where: { id: orderId }
  });
  
  expect(orderAfter.status).toBe('pending');  // ‚≠ê UNCHANGED
  expect(orderAfter.status).not.toBe('success');
  expect(orderAfter.status).not.toBe('cancelled');
});
```

---

#### 6. ‚ùå Inventory Service KH√îNG X·ª≠ L√Ω order.retry.payment

**Thi·∫øu:**
```typescript
it('should verify Inventory Service does NOT process order.retry.payment', async () => {
  // Mock Inventory Service consumer
  const inventoryConsumerMessages = [];
  
  // Inventory Service ch·ªâ subscribe order.create
  await inventoryConsumer.subscribe({ topic: 'order.create' });
  
  // Publish order.retry.payment
  await kafka.publish('order.retry.payment', {
    orderId: 'order-123',
    isRetry: true
  });
  
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Verify: Inventory Service KH√îNG nh·∫≠n ƒë∆∞·ª£c message
  expect(inventoryConsumerMessages).toHaveLength(0);  // ‚≠ê EMPTY
});
```

---

### üü° MEDIUM PRIORITY - N√™n Test

#### 7. ‚ùå Multiple Retries - VNPay URL Uniqueness

```typescript
it('should generate unique VNPay URL for each retry', async () => {
  const orderId = 'order-multi-retry';
  
  // Retry 1
  const response1 = await POST('/order/retry-payment/' + orderId);
  const url1 = response1.data.paymentUrl;
  const vnpTxnRef1 = extractVnpTxnRef(url1);
  
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Retry 2
  const response2 = await POST('/order/retry-payment/' + orderId);
  const url2 = response2.data.paymentUrl;
  const vnpTxnRef2 = extractVnpTxnRef(url2);
  
  // Verify: URLs kh√°c nhau
  expect(url1).not.toBe(url2);
  
  // Verify: vnpTxnRef kh√°c nhau
  expect(vnpTxnRef1).not.toBe(vnpTxnRef2);  // ‚≠ê UNIQUE
});
```

---

#### 8. ‚ùå Retry Khi Session S·∫Øp H·∫øt H·∫°n

```typescript
it('should allow retry when session has < 1 minute remaining', async () => {
  const orderId = 'order-last-minute';
  
  // Setup: Session v·ªõi TTL = 50 gi√¢y
  await redis.setex(`order:session:${orderId}`, 50, JSON.stringify({
    orderId,
    status: 'pending',
    expiresAt: new Date(Date.now() + 50000).toISOString()
  }));
  
  // Retry payment
  const response = await POST('/order/retry-payment/' + orderId);
  
  // Verify: Retry ƒë∆∞·ª£c ch·∫•p nh·∫≠n
  expect(response.status).toBe(200);
  expect(response.data.sessionRemainingMinutes).toBeLessThan(1);
  
  // User v·∫´n nh·∫≠n ƒë∆∞·ª£c payment URL
  expect(response.data.paymentUrl).toBeDefined();
});
```

---

#### 9. ‚ùå Retry Rejected Khi Session = 0

```typescript
it('should reject retry when session TTL = 0', async () => {
  const orderId = 'order-expired-retry';
  
  // Setup: Session h·∫øt h·∫°n
  await redis.set(`order:session:${orderId}`, JSON.stringify({
    orderId,
    status: 'pending'
  }));
  
  await redis.expire(`order:session:${orderId}`, 0);  // ‚≠ê TTL = 0
  
  // Try to retry
  const response = await POST('/order/retry-payment/' + orderId);
  
  // Verify: Rejected
  expect(response.status).toBe(400);
  expect(response.data.error).toBe('SESSION_EXPIRED');
  
  // Verify: Order status updated to cancelled
  const order = await prisma.order.findUnique({ where: { id: orderId } });
  expect(order.status).toBe('cancelled');
});
```

---

## üìã SUMMARY

### ‚úÖ Test Coverage Hi·ªán T·∫°i

| Feature | Tested? | Quality |
|---------|---------|---------|
| Session kh√¥ng b·ªã x√≥a khi retry | ‚úÖ | Mock (not real Redis) |
| TTL countdown ti·∫øp t·ª•c | ‚úÖ | Conceptual (hard-coded values) |
| PaymentIntent status after cancel | ‚úÖ | Mock data |
| Complete retry flow | ‚úÖ | Timeline tracking |
| Kafka topic routing | ‚úÖ | Event structure |

### ‚ùå Test Gaps (9 cases thi·∫øu)

| Test Case | Priority | Impact |
|-----------|----------|--------|
| 1. TTL countdown th·ª±c t·∫ø | üî¥ HIGH | Critical |
| 2. PaymentIntent status transitions | üî¥ HIGH | Critical |
| 3. Multiple PaymentAttempts | üî¥ HIGH | Critical |
| 4. PaymentAttempt CANCELED status | üî¥ HIGH | Critical |
| 5. Order status unchanged | üî¥ HIGH | Critical |
| 6. Inventory kh√¥ng x·ª≠ l√Ω retry | üî¥ HIGH | Important |
| 7. VNPay URL uniqueness | üü° MEDIUM | Important |
| 8. Retry khi session s·∫Øp h·∫øt | üü° MEDIUM | Important |
| 9. Retry rejected khi TTL = 0 | üü° MEDIUM | Important |

---

## üéì K·∫æT LU·∫¨N

### Communication Summary

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           RETRY PAYMENT COMMUNICATION FLOW                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

User (Frontend)
    ‚Üì POST /retry-payment
Order Service
    ‚Üì Validates (session, TTL, order status)
    ‚Üì Publish Kafka: order.retry.payment
Payment Service
    ‚Üì Consumes order.retry.payment
    ‚Üì Find PaymentIntent (existing)
    ‚Üì Update PaymentIntent status (if needed)
    ‚Üì Create PaymentAttempt (new)
    ‚Üì Generate VNPay URL (new)
    ‚Üì Update PaymentAttempt ‚Üí PROCESSING
    ‚Üì Update PaymentIntent ‚Üí PROCESSING
    ‚Üì Publish Kafka: payment.event (with new URL)
Order Service
    ‚Üì Consumes payment.event
    ‚Üì Order status: pending (unchanged)
    ‚Üì Redis session: ACTIVE (not deleted)
    ‚Üì Return payment URL to client
User (Frontend)
    ‚Üì Redirect to VNPay v·ªõi URL m·ªõi
```

### Key Takeaways

1. ‚úÖ **PaymentIntent ƒë∆∞·ª£c t√°i s·ª≠ d·ª•ng** - 1 Order = 1 PaymentIntent
2. ‚úÖ **PaymentAttempt m·ªõi m·ªói l·∫ßn retry** - Track t·ª´ng l·∫ßn th·ª≠
3. ‚úÖ **Redis session kh√¥ng b·ªã x√≥a** - User c√≥ th·ªÉ retry nhi·ªÅu l·∫ßn
4. ‚úÖ **TTL countdown li√™n t·ª•c** - Kh√¥ng reset khi retry
5. ‚úÖ **Kafka topics t√°ch bi·ªát** - order.create ‚â† order.retry.payment
6. ‚úÖ **Inventory kh√¥ng check l·∫°i** - ƒê√£ reserve t·ª´ l·∫ßn ƒë·∫ßu

### Test Recommendations

üî¥ **∆Øu ti√™n cao:** Implement 6 test cases HIGH priority  
üü° **∆Øu ti√™n trung b√¨nh:** Implement 3 test cases MEDIUM priority  
üí° **T∆∞∆°ng lai:** Th√™m integration tests v·ªõi real Redis & Database

---

**T√†i li·ªáu n√†y:** Chi ti·∫øt workflow retry payment trong Phase 2  
**Ng√†y t·∫°o:** 30 Th√°ng 10, 2025  
**Phase:** 2 - User ƒê·∫øn VNPay  
**M·ª•c ƒë√≠ch:** Gi·∫£i th√≠ch communication flow gi·ªØa c√°c components  

