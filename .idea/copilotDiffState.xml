<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/services/product-service/src/server.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/services/product-service/src/server.ts" />
              <option name="originalContent" value="import cors from &quot;cors&quot;;&#10;import env from &quot;dotenv&quot;;&#10;import morgan from &quot;morgan&quot;;&#10;import cookieParser from &quot;cookie-parser&quot;;&#10;import { initKafka } from &quot;./utils/kafka&quot;;&#10;import productRoutes from &quot;./routes/product.routes&quot;;&#10;import categoryRoutes from &quot;./routes/category.routes&quot;;&#10;import express, { NextFunction, Request, Response } from &quot;express&quot;;&#10;&#10;env.config();&#10;&#10;const server = express();&#10;&#10;// Run kafka consumer&#10;initKafka();&#10;&#10;// Middleware's&#10;server.use(express.json());&#10;server.use(cookieParser());&#10;server.use(&#10;  cors({&#10;    origin: &quot;http://localhost:3000&quot;,&#10;  })&#10;);&#10;server.use(morgan(&quot;dev&quot;));&#10;&#10;// Routes&#10;server.use(&quot;/products&quot;, productRoutes);&#10;server.use(&quot;/categories&quot;, categoryRoutes);&#10;&#10;// Health Check Route&#10;server.get(&quot;/&quot;, (req: Request, res: Response) =&gt; {&#10;  res.status(200).json({ success: true, message: &quot;Product service is running&quot; });&#10;});&#10;&#10;// Error handling middleware&#10;server.use((err: Error, req: Request, res: Response, next: NextFunction) =&gt; {&#10;  console.error(err.stack);&#10;  res.status(500).json({&#10;    success: false,&#10;    message: &quot;Internal server error&quot;,&#10;  });&#10;});&#10;&#10;// 404 handler&#10;server.use((req: Request, res: Response) =&gt; {&#10;  res.status(404).json({&#10;    success: false,&#10;    message: &quot;Route not found&quot;,&#10;  });&#10;});&#10;&#10;const PORT = process.env.PORT || 3004;&#10;&#10;server.listen(PORT, () =&gt; {&#10;  console.log(`Product service is running on port ${PORT}`);&#10;});&#10;" />
              <option name="updatedContent" value="import cors from &quot;cors&quot;;&#10;import env from &quot;dotenv&quot;;&#10;import morgan from &quot;morgan&quot;;&#10;import cookieParser from &quot;cookie-parser&quot;;&#10;import { initKafka } from &quot;./utils/kafka&quot;;&#10;import productRoutes from &quot;./routes/product.routes&quot;;&#10;import categoryRoutes from &quot;./routes/category.routes&quot;;&#10;import express, { NextFunction, Request, Response } from &quot;express&quot;;&#10;&#10;env.config();&#10;&#10;const server = express();&#10;&#10;// Run kafka consumer&#10;initKafka();&#10;&#10;// Middleware's&#10;server.use(express.json());&#10;server.use(cookieParser());&#10;server.use(&#10;  cors({&#10;    origin: &quot;http://localhost:3000&quot;,&#10;  })&#10;);&#10;server.use(morgan(&quot;dev&quot;));&#10;&#10;// Routes&#10;server.use(&quot;/products&quot;, productRoutes);&#10;server.use(&quot;/categories&quot;, categoryRoutes);&#10;&#10;// Health Check Route&#10;server.get(&quot;/&quot;, (req: Request, res: Response) =&gt; {&#10;  res.status(200).json({ success: true, message: &quot;Product service is running&quot; });&#10;});&#10;&#10;// Error handling middleware&#10;server.use((err: Error, req: Request, res: Response, next: NextFunction) =&gt; {&#10;  console.error(err.stack);&#10;  res.status(500).json({&#10;    success: false,&#10;    message: &quot;Internal server error&quot;,&#10;  });&#10;});&#10;&#10;// 404 handler&#10;server.use((req: Request, res: Response) =&gt; {&#10;  res.status(404).json({&#10;    success: false,&#10;    message: &quot;Route not found&quot;,&#10;  });&#10;});&#10;&#10;const PORT = process.env.PORT || 3004;&#10;&#10;server.listen(PORT, () =&gt; {&#10;  console.log(`Product service is running on port ${PORT}`);&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/services/user-service/src/controllers/auth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/services/user-service/src/controllers/auth.ts" />
              <option name="originalContent" value="import { Request, Response } from &quot;express&quot;;&#10;import bcrypt from &quot;bcryptjs&quot;;&#10;import jwt from &quot;jsonwebtoken&quot;;&#10;import prisma from &quot;../lib/prisma&quot;;&#10;&#10;// Đăng ký user&#10;export const register = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const { email, password, name, phone, role = &quot;CUSTOMER&quot; } = req.body;&#10;&#10;    // Kiểm tra email đã tồn tại&#10;    const existingUser = await prisma.user.findUnique({&#10;      where: { email }&#10;    });&#10;&#10;    if (existingUser) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: &quot;Email đã được sử dụng&quot;&#10;      });&#10;    }&#10;&#10;    // Mã hóa password&#10;    const hashedPassword = await bcrypt.hash(password, 12);&#10;&#10;    // Tạo user mới&#10;    const user = await prisma.user.create({&#10;      data: {&#10;        email,&#10;        password: hashedPassword,&#10;        name,&#10;        phone,&#10;        role: role as any&#10;      },&#10;      select: {&#10;        id: true,&#10;        email: true,&#10;        name: true,&#10;        phone: true,&#10;        role: true,&#10;        status: true,&#10;        createdAt: true&#10;      }&#10;    });&#10;&#10;    // Tạo JWT token&#10;    const token = jwt.sign(&#10;      {&#10;        userId: user.id,&#10;        email: user.email,&#10;        role: user.role&#10;      },&#10;      process.env.JWT_SECRET || &quot;secret&quot;,&#10;      { expiresIn: &quot;7d&quot; }&#10;    );&#10;&#10;    res.status(201).json({&#10;      success: true,&#10;      data: {&#10;        user,&#10;        token&#10;      },&#10;      message: &quot;Đăng ký thành công&quot;&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error registering user:&quot;, error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi đăng ký&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Đăng nhập&#10;export const login = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const { email, password } = req.body;&#10;&#10;    // Tìm user theo email&#10;    const user = await prisma.user.findUnique({&#10;      where: { email },&#10;      include: {&#10;        store: true&#10;      }&#10;    });&#10;&#10;    if (!user) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: &quot;Email hoặc mật khẩu không đúng&quot;&#10;      });&#10;    }&#10;&#10;    // Kiểm tra account status&#10;    if (user.status !== &quot;ACTIVE&quot;) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: &quot;Tài khoản đã bị khóa hoặc vô hiệu hóa&quot;&#10;      });&#10;    }&#10;&#10;    // Kiểm tra password&#10;    const isPasswordValid = await bcrypt.compare(password, user.password);&#10;    if (!isPasswordValid) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: &quot;Email hoặc mật khẩu không đúng&quot;&#10;      });&#10;    }&#10;&#10;    // Tạo JWT token&#10;    const token = jwt.sign(&#10;      {&#10;        userId: user.id,&#10;        email: user.email,&#10;        role: user.role&#10;      },&#10;      process.env.JWT_SECRET || &quot;secret&quot;,&#10;      { expiresIn: &quot;7d&quot; }&#10;    );&#10;&#10;    // Trả về thông tin user (không bao gồm password)&#10;    const { password: _, ...userWithoutPassword } = user;&#10;&#10;    res.json({&#10;      success: true,&#10;      data: {&#10;        user: userWithoutPassword,&#10;        token&#10;      },&#10;      message: &quot;Đăng nhập thành công&quot;&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error logging in:&quot;, error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi đăng nhập&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Lấy thông tin profile&#10;export const getProfile = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const userId = (req as any).user.userId;&#10;&#10;    const user = await prisma.user.findUnique({&#10;      where: { id: userId },&#10;      include: {&#10;        addresses: true,&#10;        store: true,&#10;        paymentMethods: true&#10;      }&#10;    });&#10;&#10;    if (!user) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: &quot;Không tìm thấy user&quot;&#10;      });&#10;    }&#10;&#10;    // Loại bỏ password khỏi response&#10;    const { password, ...userWithoutPassword } = user;&#10;&#10;    res.json({&#10;      success: true,&#10;      data: userWithoutPassword&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error getting profile:&quot;, error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi lấy thông tin profile&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Cập nhật profile&#10;export const updateProfile = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const userId = (req as any).user.userId;&#10;    const { name, phone, avatar } = req.body;&#10;&#10;    const user = await prisma.user.update({&#10;      where: { id: userId },&#10;      data: {&#10;        ...(name &amp;&amp; { name }),&#10;        ...(phone &amp;&amp; { phone }),&#10;        ...(avatar &amp;&amp; { avatar })&#10;      },&#10;      select: {&#10;        id: true,&#10;        email: true,&#10;        name: true,&#10;        phone: true,&#10;        avatar: true,&#10;        role: true,&#10;        status: true,&#10;        createdAt: true,&#10;        updatedAt: true&#10;      }&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      data: user,&#10;      message: &quot;Cập nhật profile thành công&quot;&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error updating profile:&quot;, error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi cập nhật profile&quot;&#10;    });&#10;  }&#10;};&#10;" />
              <option name="updatedContent" value="import { Request, Response } from &quot;express&quot;;&#10;import bcrypt from &quot;bcryptjs&quot;;&#10;import jwt from &quot;jsonwebtoken&quot;;&#10;import prisma from &quot;../lib/prisma&quot;;&#10;import crypto from &quot;crypto&quot;;&#10;&#10;// Đăng ký user&#10;export const register = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const { email, password, name, phone, role = &quot;CUSTOMER&quot; } = req.body;&#10;&#10;    // Kiểm tra email đã tồn tại&#10;    const existingUser = await prisma.user.findUnique({&#10;      where: { email }&#10;    });&#10;&#10;    if (existingUser) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: &quot;Email đã được sử dụng&quot;&#10;      });&#10;    }&#10;&#10;    // Mã hóa password&#10;    const hashedPassword = await bcrypt.hash(password, 12);&#10;&#10;    // Tạo user mới&#10;    const user = await prisma.user.create({&#10;      data: {&#10;        email,&#10;        password: hashedPassword,&#10;        name,&#10;        phone,&#10;        role: role as any&#10;      },&#10;      select: {&#10;        id: true,&#10;        email: true,&#10;        name: true,&#10;        phone: true,&#10;        role: true,&#10;        status: true,&#10;        createdAt: true&#10;      }&#10;    });&#10;&#10;    // Tạo JWT token với jti để hỗ trợ logout&#10;    const jti = crypto.randomUUID();&#10;    const token = jwt.sign(&#10;      {&#10;        userId: user.id,&#10;        email: user.email,&#10;        role: user.role&#10;      },&#10;      process.env.JWT_SECRET || &quot;secret&quot;,&#10;      { expiresIn: &quot;7d&quot;, jwtid: jti }&#10;    );&#10;&#10;    res.status(201).json({&#10;      success: true,&#10;      data: {&#10;        user,&#10;        token&#10;      },&#10;      message: &quot;Đăng ký thành công&quot;&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error registering user:&quot;, error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi đăng ký&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Đăng nhập&#10;export const login = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const { email, password } = req.body;&#10;&#10;    // Tìm user theo email&#10;    const user = await prisma.user.findUnique({&#10;      where: { email },&#10;      include: {&#10;        store: true&#10;      }&#10;    });&#10;&#10;    if (!user) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: &quot;Email hoặc mật khẩu không đúng&quot;&#10;      });&#10;    }&#10;&#10;    // Kiểm tra account status&#10;    if (user.status !== &quot;ACTIVE&quot;) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: &quot;Tài khoản đã bị khóa hoặc vô hiệu hóa&quot;&#10;      });&#10;    }&#10;&#10;    // Kiểm tra password&#10;    const isPasswordValid = await bcrypt.compare(password, user.password);&#10;    if (!isPasswordValid) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: &quot;Email hoặc mật khẩu không đúng&quot;&#10;      });&#10;    }&#10;&#10;    // Tạo JWT token với jti để hỗ trợ logout&#10;    const jti = crypto.randomUUID();&#10;    const token = jwt.sign(&#10;      {&#10;        userId: user.id,&#10;        email: user.email,&#10;        role: user.role&#10;      },&#10;      process.env.JWT_SECRET || &quot;secret&quot;,&#10;      { expiresIn: &quot;7d&quot;, jwtid: jti }&#10;    );&#10;&#10;    // Trả về thông tin user (không bao gồm password)&#10;    const { password: _, ...userWithoutPassword } = user as any;&#10;&#10;    res.json({&#10;      success: true,&#10;      data: {&#10;        user: userWithoutPassword,&#10;        token&#10;      },&#10;      message: &quot;Đăng nhập thành công&quot;&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error logging in:&quot;, error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi đăng nhập&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Lấy thông tin profile&#10;export const getProfile = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const userId = (req as any).user.userId;&#10;&#10;    const user = await prisma.user.findUnique({&#10;      where: { id: userId },&#10;      include: {&#10;        addresses: true,&#10;        store: true,&#10;        paymentMethods: true&#10;      }&#10;    });&#10;&#10;    if (!user) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: &quot;Không tìm thấy user&quot;&#10;      });&#10;    }&#10;&#10;    // Loại bỏ password khỏi response&#10;    const { password, ...userWithoutPassword } = user as any;&#10;&#10;    res.json({&#10;      success: true,&#10;      data: userWithoutPassword&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error getting profile:&quot;, error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi lấy thông tin profile&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Cập nhật profile&#10;export const updateProfile = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const userId = (req as any).user.userId;&#10;    const { name, phone, avatar } = req.body;&#10;&#10;    const user = await prisma.user.update({&#10;      where: { id: userId },&#10;      data: {&#10;        ...(name &amp;&amp; { name }),&#10;        ...(phone &amp;&amp; { phone }),&#10;        ...(avatar &amp;&amp; { avatar })&#10;      },&#10;      select: {&#10;        id: true,&#10;        email: true,&#10;        name: true,&#10;        phone: true,&#10;        avatar: true,&#10;        role: true,&#10;        status: true,&#10;        createdAt: true,&#10;        updatedAt: true&#10;      }&#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      data: user,&#10;      message: &quot;Cập nhật profile thành công&quot;&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error updating profile:&quot;, error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi cập nhật profile&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Đăng xuất - hủy token hiện tại&#10;export const logout = async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const authHeader = req.headers.authorization;&#10;    const token = authHeader &amp;&amp; authHeader.split(&quot; &quot;)[1]; // Bearer TOKEN&#10;&#10;    if (!token) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: &quot;Không có token để đăng xuất&quot;&#10;      });&#10;    }&#10;&#10;    // Xác thực token để lấy thông tin và thời gian hết hạn&#10;    let decoded: any;&#10;    try {&#10;      decoded = jwt.verify(token, process.env.JWT_SECRET || &quot;secret&quot;, {&#10;        ignoreExpiration: false&#10;      });&#10;    } catch (err) {&#10;      // Nếu token đã hết hạn, vẫn tiến hành thu hồi dựa trên payload có thể không đọc được&#10;      // Khi hết hạn, verify sẽ ném lỗi, nên ta decode không verify để lấy jti/exp&#10;      try {&#10;        decoded = jwt.decode(token);&#10;      } catch {&#10;        decoded = null;&#10;      }&#10;    }&#10;&#10;    // Tính expiresAt: nếu có exp thì dùng, nếu không có thì đặt 7 ngày từ bây giờ như mặc định&#10;    const expSeconds = decoded?.exp as number | undefined;&#10;    const expiresAt = expSeconds&#10;      ? new Date(expSeconds * 1000)&#10;      : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);&#10;&#10;    const userId = (req as any).user?.userId ?? decoded?.userId ?? null;&#10;    const jti = (decoded as any)?.jti as string | undefined;&#10;&#10;    // Tạo hash của token (đề phòng trường hợp không có jti)&#10;    const tokenHash = crypto.createHash(&quot;sha256&quot;).update(token).digest(&quot;hex&quot;);&#10;&#10;    // Lưu token bị thu hồi. Có thể đã tồn tại -&gt; bỏ qua lỗi unique&#10;    try {&#10;      await prisma.revokedToken.create({&#10;        data: {&#10;          jti: jti ?? null,&#10;          tokenHash,&#10;          userId: userId ?? undefined,&#10;          expiresAt&#10;        }&#10;      });&#10;    } catch (e: any) {&#10;      // Unique constraint =&gt; đã thu hồi trước đó, coi như thành công&#10;      const msg = e?.message || &quot;&quot;;&#10;      if (!msg.includes(&quot;Unique constraint failed&quot;)) {&#10;        throw e;&#10;      }&#10;    }&#10;&#10;    // Có thể xóa cookie nếu lưu token ở cookie (không áp dụng ở đây, chỉ để tham khảo)&#10;    // res.clearCookie(&quot;token&quot;);&#10;&#10;    return res.status(200).json({&#10;      success: true,&#10;      message: &quot;Đăng xuất thành công&quot;&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error logging out:&quot;, error);&#10;    return res.status(500).json({&#10;      success: false,&#10;      message: &quot;Lỗi khi đăng xuất&quot;&#10;    });&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/services/user-service/src/middleware/auth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/services/user-service/src/middleware/auth.ts" />
              <option name="originalContent" value="import { Request, Response, NextFunction } from &quot;express&quot;;&#10;import jwt from &quot;jsonwebtoken&quot;;&#10;import prisma from &quot;../lib/prisma&quot;;&#10;&#10;// Interface để extend Request object&#10;interface AuthRequest extends Request {&#10;  user?: {&#10;    userId: string;&#10;    email: string;&#10;    role: string;&#10;  };&#10;}&#10;&#10;// Middleware xác thực JWT token&#10;export const authenticateToken = async (&#10;  req: AuthRequest,&#10;  res: Response,&#10;  next: NextFunction&#10;) =&gt; {&#10;  try {&#10;    const authHeader = req.headers.authorization;&#10;    const token = authHeader &amp;&amp; authHeader.split(&quot; &quot;)[1]; // Bearer TOKEN&#10;&#10;    if (!token) {&#10;      return res.status(401).json({&#10;        success: false,&#10;        message: &quot;Không có token, truy cập bị từ chối&quot;&#10;      });&#10;    }&#10;&#10;    // Verify token&#10;    const decoded = jwt.verify(token, process.env.JWT_SECRET || &quot;secret&quot;) as any;&#10;&#10;    // Kiểm tra user còn tồn tại và active&#10;    const user = await prisma.user.findUnique({&#10;      where: { id: decoded.userId },&#10;      select: { id: true, email: true, role: true, status: true }&#10;    });&#10;&#10;    if (!user || user.status !== &quot;ACTIVE&quot;) {&#10;      return res.status(401).json({&#10;        success: false,&#10;        message: &quot;Token không hợp lệ hoặc tài khoản đã bị khóa&quot;&#10;      });&#10;    }&#10;&#10;    req.user = {&#10;      userId: user.id,&#10;      email: user.email,&#10;      role: user.role&#10;    };&#10;&#10;    next();&#10;  } catch (error) {&#10;    console.error(&quot;Auth error:&quot;, error);&#10;    res.status(401).json({&#10;      success: false,&#10;      message: &quot;Token không hợp lệ&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Middleware kiểm tra role STORE_ADMIN&#10;export const requireStoreAdmin = (&#10;  req: AuthRequest,&#10;  res: Response,&#10;  next: NextFunction&#10;) =&gt; {&#10;  if (!req.user) {&#10;    return res.status(401).json({&#10;      success: false,&#10;      message: &quot;Chưa xác thực&quot;&#10;    });&#10;  }&#10;&#10;  if (req.user.role !== &quot;STORE_ADMIN&quot;) {&#10;    return res.status(403).json({&#10;      success: false,&#10;      message: &quot;Chỉ admin cửa hàng mới có quyền thực hiện hành động này&quot;&#10;    });&#10;  }&#10;&#10;  next();&#10;};&#10;&#10;// Middleware kiểm tra role CUSTOMER&#10;export const requireCustomer = (&#10;  req: AuthRequest,&#10;  res: Response,&#10;  next: NextFunction&#10;) =&gt; {&#10;  if (!req.user) {&#10;    return res.status(401).json({&#10;      success: false,&#10;      message: &quot;Chưa xác thực&quot;&#10;    });&#10;  }&#10;&#10;  if (req.user.role !== &quot;CUSTOMER&quot;) {&#10;    return res.status(403).json({&#10;      success: false,&#10;      message: &quot;Chỉ khách hàng mới có quyền thực hiện hành động này&quot;&#10;    });&#10;  }&#10;&#10;  next();&#10;};&#10;&#10;// Middleware kiểm tra nhiều role&#10;export const requireRoles = (allowedRoles: string[]) =&gt; {&#10;  return (req: AuthRequest, res: Response, next: NextFunction) =&gt; {&#10;    if (!req.user) {&#10;      return res.status(401).json({&#10;        success: false,&#10;        message: &quot;Chưa xác thực&quot;&#10;      });&#10;    }&#10;&#10;    if (!allowedRoles.includes(req.user.role)) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: &quot;Bạn không có quyền thực hiện hành động này&quot;&#10;      });&#10;    }&#10;&#10;    next();&#10;  };&#10;};&#10;" />
              <option name="updatedContent" value="import { Request, Response, NextFunction } from &quot;express&quot;;&#10;import jwt from &quot;jsonwebtoken&quot;;&#10;import prisma from &quot;../lib/prisma&quot;;&#10;import crypto from &quot;crypto&quot;;&#10;&#10;// Interface để extend Request object&#10;interface AuthRequest extends Request {&#10;  user?: {&#10;    userId: string;&#10;    email: string;&#10;    role: string;&#10;  };&#10;}&#10;&#10;// Middleware xác thực JWT token&#10;export const authenticateToken = async (&#10;  req: AuthRequest,&#10;  res: Response,&#10;  next: NextFunction&#10;) =&gt; {&#10;  try {&#10;    const authHeader = req.headers.authorization;&#10;    const token = authHeader &amp;&amp; authHeader.split(&quot; &quot;)[1]; // Bearer TOKEN&#10;&#10;    if (!token) {&#10;      return res.status(401).json({&#10;        success: false,&#10;        message: &quot;Không có token, truy cập bị từ chối&quot;&#10;      });&#10;    }&#10;&#10;    // Verify token&#10;    const decoded = jwt.verify(token, process.env.JWT_SECRET || &quot;secret&quot;) as any;&#10;&#10;    // Kiểm tra token đã bị thu hồi (đã logout) hay chưa&#10;    const jti = decoded?.jti as string | undefined;&#10;    const tokenHash = crypto.createHash(&quot;sha256&quot;).update(token).digest(&quot;hex&quot;);&#10;&#10;    const revoked = await prisma.revokedToken.findFirst({&#10;      where: {&#10;        AND: [&#10;          {&#10;            OR: [&#10;              ...(jti ? [{ jti }] as any[] : []),&#10;              { tokenHash }&#10;            ]&#10;          },&#10;          { expiresAt: { gt: new Date() } }&#10;        ]&#10;      }&#10;    });&#10;&#10;    if (revoked) {&#10;      return res.status(401).json({&#10;        success: false,&#10;        message: &quot;Token đã bị thu hồi. Vui lòng đăng nhập lại.&quot;&#10;      });&#10;    }&#10;&#10;    // Kiểm tra user còn tồn tại và active&#10;    const user = await prisma.user.findUnique({&#10;      where: { id: decoded.userId },&#10;      select: { id: true, email: true, role: true, status: true }&#10;    });&#10;&#10;    if (!user || user.status !== &quot;ACTIVE&quot;) {&#10;      return res.status(401).json({&#10;        success: false,&#10;        message: &quot;Token không hợp lệ hoặc tài khoản đã bị khóa&quot;&#10;      });&#10;    }&#10;&#10;    req.user = {&#10;      userId: user.id,&#10;      email: user.email,&#10;      role: user.role&#10;    };&#10;&#10;    next();&#10;  } catch (error) {&#10;    console.error(&quot;Auth error:&quot;, error);&#10;    res.status(401).json({&#10;      success: false,&#10;      message: &quot;Token không hợp lệ&quot;&#10;    });&#10;  }&#10;};&#10;&#10;// Middleware kiểm tra role STORE_ADMIN&#10;export const requireStoreAdmin = (&#10;  req: AuthRequest,&#10;  res: Response,&#10;  next: NextFunction&#10;) =&gt; {&#10;  if (!req.user) {&#10;    return res.status(401).json({&#10;      success: false,&#10;      message: &quot;Chưa xác thực&quot;&#10;    });&#10;  }&#10;&#10;  if (req.user.role !== &quot;STORE_ADMIN&quot;) {&#10;    return res.status(403).json({&#10;      success: false,&#10;      message: &quot;Chỉ admin cửa hàng mới có quyền thực hiện hành động này&quot;&#10;    });&#10;  }&#10;&#10;  next();&#10;};&#10;&#10;// Middleware kiểm tra role CUSTOMER&#10;export const requireCustomer = (&#10;  req: AuthRequest,&#10;  res: Response,&#10;  next: NextFunction&#10;) =&gt; {&#10;  if (!req.user) {&#10;    return res.status(401).json({&#10;      success: false,&#10;      message: &quot;Chưa xác thực&quot;&#10;    });&#10;  }&#10;&#10;  if (req.user.role !== &quot;CUSTOMER&quot;) {&#10;    return res.status(403).json({&#10;      success: false,&#10;      message: &quot;Chỉ khách hàng mới có quyền thực hiện hành động này&quot;&#10;    });&#10;  }&#10;&#10;  next();&#10;};&#10;&#10;// Middleware kiểm tra nhiều role&#10;export const requireRoles = (allowedRoles: string[]) =&gt; {&#10;  return (req: AuthRequest, res: Response, next: NextFunction) =&gt; {&#10;    if (!req.user) {&#10;      return res.status(401).json({&#10;        success: false,&#10;        message: &quot;Chưa xác thực&quot;&#10;      });&#10;    }&#10;&#10;    if (!allowedRoles.includes(req.user.role)) {&#10;      return res.status(403).json({&#10;        success: false,&#10;        message: &quot;Bạn không có quyền thực hiện hành động này&quot;&#10;      });&#10;    }&#10;&#10;    next();&#10;  };&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/services/user-service/src/routes/auth.routes.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/services/user-service/src/routes/auth.routes.ts" />
              <option name="originalContent" value="import { Router } from &quot;express&quot;;&#10;import {&#10;  register,&#10;  login,&#10;  getProfile,&#10;  updateProfile&#10;} from &quot;../controllers/auth&quot;;&#10;import { authenticateToken } from &quot;../middleware/auth&quot;;&#10;&#10;const router = Router();&#10;&#10;// Public routes&#10;router.post(&quot;/register&quot;, register);&#10;router.post(&quot;/login&quot;, login);&#10;&#10;// Protected routes&#10;router.get(&quot;/profile&quot;, authenticateToken, getProfile);&#10;router.put(&quot;/profile&quot;, authenticateToken, updateProfile);&#10;&#10;export default router;&#10;" />
              <option name="updatedContent" value="import { Router } from &quot;express&quot;;&#10;import {&#10;  register,&#10;  login,&#10;  getProfile,&#10;  updateProfile,&#10;  logout&#10;} from &quot;../controllers/auth&quot;;&#10;import { authenticateToken } from &quot;../middleware/auth&quot;;&#10;&#10;const router = Router();&#10;&#10;// Public routes&#10;router.post(&quot;/register&quot;, register);&#10;router.post(&quot;/login&quot;, login);&#10;&#10;// Protected routes&#10;router.get(&quot;/profile&quot;, authenticateToken, getProfile);&#10;router.put(&quot;/profile&quot;, authenticateToken, updateProfile);&#10;router.post(&quot;/logout&quot;, authenticateToken, logout);&#10;&#10;export default router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/cnmp-fooddelivery/src/components/MenuSection.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/cnmp-fooddelivery/src/components/MenuSection.tsx" />
              <option name="updatedContent" value="import { Card, CardContent } from &quot;@/components/ui/card&quot;;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import { Badge } from &quot;@/components/ui/badge&quot;;&#10;import { Star, Plus, Minus } from &quot;lucide-react&quot;;&#10;import { useCart } from &quot;@/contexts/cart-context&quot;;&#10;&#10;interface MenuItem {&#10;  id: number;&#10;  name: string;&#10;  description: string;&#10;  price: number;&#10;  image: string;&#10;  popular: boolean;&#10;}&#10;&#10;interface MenuSectionData {&#10;  category: string;&#10;  items: MenuItem[];&#10;}&#10;&#10;interface MenuSectionProps {&#10;  section: MenuSectionData;&#10;  restaurantId: number;&#10;  restaurantName: string;&#10;}&#10;&#10;const MenuSection = ({ section, restaurantId, restaurantName }: MenuSectionProps) =&gt; {&#10;  const { state, dispatch } = useCart();&#10;&#10;  const formatPrice = (price: number) =&gt; {&#10;    return new Intl.NumberFormat('vi-VN', {&#10;      style: 'currency',&#10;      currency: 'VND'&#10;    }).format(price);&#10;  };&#10;&#10;  const handleAddToCart = (item: MenuItem) =&gt; {&#10;    dispatch({&#10;      type: &quot;ADD_ITEM&quot;,&#10;      payload: {&#10;        id: item.id.toString(),&#10;        name: item.name,&#10;        price: item.price,&#10;        imageUrl: item.image,&#10;      },&#10;    });&#10;  };&#10;&#10;  const handleUpdateQuantity = (itemId: string, quantity: number) =&gt; {&#10;    dispatch({&#10;      type: &quot;UPDATE_QUANTITY&quot;,&#10;      payload: { id: itemId, quantity },&#10;    });&#10;  };&#10;&#10;  const getQuantityInCart = (itemId: string) =&gt; {&#10;    const cartItem = state.items.find((item) =&gt; item.id === itemId);&#10;    return cartItem?.quantity || 0;&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;mb-8&quot;&gt;&#10;      &lt;h2 className=&quot;text-2xl font-bold text-foreground mb-4&quot;&gt;{section.category}&lt;/h2&gt;&#10;      &#10;      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-4&quot;&gt;&#10;        {section.items.map((item) =&gt; {&#10;          const quantity = getQuantityInCart(item.id.toString());&#10;          &#10;          return (&#10;            &lt;Card key={item.id} className=&quot;group cursor-pointer overflow-hidden hover:shadow-lg transition-all duration-300&quot;&gt;&#10;              &lt;div className=&quot;flex&quot;&gt;&#10;                {/* Item Info */}&#10;                &lt;CardContent className=&quot;flex-1 p-4&quot;&gt;&#10;                  &lt;div className=&quot;flex items-start justify-between mb-2&quot;&gt;&#10;                    &lt;div className=&quot;flex-1&quot;&gt;&#10;                      &lt;div className=&quot;flex items-center gap-2 mb-1&quot;&gt;&#10;                        &lt;h3 className=&quot;font-semibold text-lg text-foreground group-hover:text-primary transition-colors&quot;&gt;&#10;                          {item.name}&#10;                        &lt;/h3&gt;&#10;                        {item.popular &amp;&amp; (&#10;                          &lt;Badge className=&quot;bg-orange-100 text-orange-800 text-xs&quot;&gt;&#10;                            &lt;Star className=&quot;w-3 h-3 mr-1 fill-current&quot; /&gt;&#10;                            Phổ biến&#10;                          &lt;/Badge&gt;&#10;                        )}&#10;                      &lt;/div&gt;&#10;                      &#10;                      &lt;p className=&quot;text-sm text-muted-foreground mb-3 line-clamp-2&quot;&gt;&#10;                        {item.description}&#10;                      &lt;/p&gt;&#10;                      &#10;                      &lt;p className=&quot;text-xl font-bold text-primary mb-3&quot;&gt;&#10;                        {formatPrice(item.price)}&#10;                      &lt;/p&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                  &#10;                  {/* Add to Cart Controls */}&#10;                  &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                    &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;&#10;                      Giao trong 15-20 phút&#10;                    &lt;/div&gt;&#10;                    &#10;                    {quantity === 0 ? (&#10;                      &lt;Button&#10;                        size=&quot;sm&quot;&#10;                        onClick={() =&gt; handleAddToCart(item)}&#10;                        className=&quot;h-8 px-4&quot;&#10;                      &gt;&#10;                        &lt;Plus className=&quot;w-4 h-4 mr-1&quot; /&gt;&#10;                        Thêm&#10;                      &lt;/Button&gt;&#10;                    ) : (&#10;                      &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                        &lt;Button&#10;                          variant=&quot;outline&quot;&#10;                          size=&quot;sm&quot;&#10;                          className=&quot;h-8 w-8 p-0&quot;&#10;                          onClick={() =&gt; handleUpdateQuantity(item.id.toString(), quantity - 1)}&#10;                        &gt;&#10;                          &lt;Minus className=&quot;w-3 h-3&quot; /&gt;&#10;                        &lt;/Button&gt;&#10;                        &lt;span className=&quot;font-semibold min-w-[2rem] text-center&quot;&gt;&#10;                          {quantity}&#10;                        &lt;/span&gt;&#10;                        &lt;Button&#10;                          size=&quot;sm&quot;&#10;                          className=&quot;h-8 w-8 p-0&quot;&#10;                          onClick={() =&gt; handleUpdateQuantity(item.id.toString(), quantity + 1)}&#10;                        &gt;&#10;                          &lt;Plus className=&quot;w-3 h-3&quot; /&gt;&#10;                        &lt;/Button&gt;&#10;                      &lt;/div&gt;&#10;                    )}&#10;                  &lt;/div&gt;&#10;                &lt;/CardContent&gt;&#10;&#10;                {/* Item Image */}&#10;                &lt;div className=&quot;w-24 md:w-32 h-24 md:h-32 relative flex-shrink-0&quot;&gt;&#10;                  &lt;img&#10;                    src={item.image}&#10;                    alt={item.name}&#10;                    className=&quot;w-full h-full object-cover group-hover:scale-105 transition-transform duration-300&quot;&#10;                  /&gt;&#10;                  {item.popular &amp;&amp; (&#10;                    &lt;div className=&quot;absolute top-1 right-1&quot;&gt;&#10;                      &lt;Badge className=&quot;bg-primary text-primary-foreground text-xs px-1 py-0&quot;&gt;&#10;                        HOT&#10;                      &lt;/Badge&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/Card&gt;&#10;          );&#10;        })}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default MenuSection;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>